#!/usr/bin/env node
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';
import { createWorkDir, deleteWorkDir } from './workDir/index.js';
import { parseProject } from './parseProject/index.js';
import { generateLock } from './generateLock/generateLock.js';
import { audit } from './audit/index.js';
import { render } from './render/index.js';
import fs from 'fs';
import path from 'path';

// // 创建 MCP 服务器实例并声明能力
const server = new McpServer({
  name: 'mcp-vulnerability-checker',
  title: '前端工程安全审计服务',
  version: '1.0.0',
});

// // 注册工具（拆分版）

// 1) 创建工作目录
server.registerTool(
  'createWorkDir',
  {
    title: '创建工作目录',
    description: '在指定基路径下创建唯一的工作目录并返回路径',
    inputSchema: {
      basePath: z.string().describe('保存工作文件的基路径（绝对路径）'),
    },
  },
  async ({ basePath }) => {
    const workDir = createWorkDir(basePath);
    return { content: [{ type: 'text', text: workDir }] };
  }
);

// 2) 解析项目，返回 package.json 字符串
server.registerTool(
  'parseProject',
  {
    title: '解析项目生成 package.json',
    description: '解析 projectRoot（本地路径或远程仓库URL），返回 package.json 字符串',
    inputSchema: {
      projectRoot: z.string().describe('项目根路径（绝对路径）或远程仓库URL'),
    },
  },
  async ({ projectRoot }) => {
    const packageJson = await parseProject(projectRoot);
    return { content: [{ type: 'text', text: JSON.stringify(packageJson) }] };
  }
);

// 3) 生成 lock 文件
server.registerTool(
  'generateLock',
  {
    title: '生成锁文件',
    description: '在工作目录内根据 package.json 生成 lock 文件',
    inputSchema: {
      workDir: z.string().describe('工作目录绝对路径'),
      packageJson: z.string().describe('package.json 对象的 JSON 字符串'),
    },
  },
  async ({ workDir, packageJson }) => {
    const pkg = JSON.parse(packageJson);
    await generateLock(workDir, pkg);
    return { content: [{ type: 'text', text: 'ok' }] };
  }
);

// 4) 审计依赖，返回规范化结果 JSON 字符串
server.registerTool(
  'auditDependencies',
  {
    title: '审计依赖',
    description: '对工作目录进行 npm audit 并返回规范化后的结果 JSON 字符串',
    inputSchema: {
      workDir: z.string().describe('工作目录绝对路径'),
      packageJson: z.string().describe('package.json 对象的 JSON 字符串'),
    },
  },
  async ({ workDir, packageJson }) => {
    const pkg = JSON.parse(packageJson);
    const auditResult = await audit(workDir, pkg);
    return { content: [{ type: 'text', text: JSON.stringify(auditResult) }] };
  }
);

// 5) 渲染审计报告为 Markdown 字符串
server.registerTool(
  'renderAuditReport',
  {
    title: '渲染审计报告',
    description: '将审计结果与 package.json 渲染成 Markdown 字符串',
    inputSchema: {
      auditResult: z.string().describe('规范化审计结果的 JSON 字符串'),
      packageJson: z.string().describe('package.json 对象的 JSON 字符串'),
    },
  },
  async ({ auditResult, packageJson }) => {
    const result = JSON.parse(auditResult);
    const pkg = JSON.parse(packageJson);
    const markdown = await render(result, pkg);
    return { content: [{ type: 'text', text: markdown }] };
  }
);

// 6) 写入文件到磁盘
server.registerTool(
  'writeFile',
  {
    title: '写入文件',
    description: '将内容写入到指定路径（若目录不存在会递归创建）',
    inputSchema: {
      targetPath: z.string().describe('目标文件绝对路径'),
      content: z.string().describe('写入内容'),
    },
  },
  async ({ targetPath, content }) => {
    const dir = path.dirname(targetPath);
    await fs.promises.mkdir(dir, { recursive: true });
    await fs.promises.writeFile(targetPath, content);
    return { content: [{ type: 'text', text: targetPath }] };
  }
);

// 7) 删除工作目录
server.registerTool(
  'deleteWorkDir',
  {
    title: '删除工作目录',
    description: '删除指定的工作目录',
    inputSchema: {
      workDir: z.string().describe('工作目录绝对路径'),
    },
  },
  async ({ workDir }) => {
    await deleteWorkDir(workDir);
    return { content: [{ type: 'text', text: 'ok' }] };
  }
);

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('MCP Vulnerability Checker running on stdio');
}

main().catch((error) => {
  console.error('Fatal error in main():', error);
  process.exit(1);
});
