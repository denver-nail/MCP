import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';
import { auditPackage } from './tool.js';

// // 创建 MCP 服务器实例并声明能力
const server = new McpServer({
  name: 'mcp-vulnerability-checker',
  title: '前端工程安全审计服务',
  version: '1.0.0',
});

// // 注册工具

server.registerTool(
  'auditPackage',
  {
    title:
      '审计前端工程的所有直接和间接依赖，得到安全审计结果。支持本地工程的审计，也支持远程仓库的审计。审计结果为标准格式的markdown字符串，不用修改，直接用于展示即可。',
    description:
      '审计前端工程的所有直接和间接依赖，得到安全审计结果。支持本地工程的审计，也支持远程仓库的审计。审计结果为标准格式的markdown字符串，不用修改，直接用于展示即可。',
    inputSchema: {
      projectRoot: z
        .string()
        .describe('审查工程的路径，可以是本地工程的根路径，或者远程仓库的URL地址'),
      savePath: z.string().describe('保存审计结果的路径'),
    },
  },
  async ({ projectRoot, savePath }) => {
    await auditPackage(projectRoot, savePath);

    return {
      content: [
        {
          type: 'text',
          text: `审计完成，结果已保存到: ${savePath}`,
        },
      ],
    };
  }
);

async function main() {
  // 创建一个标准输入输出服务器对象
  const transport = new StdioServerTransport();
  // 连接服务器
  await server.connect(transport);
  //使用error打印而不用log
  console.error('AuditPackage MCP Server running on stdio');
}

main().catch((error) => {
  console.error('Fatal error in main():', error);
  process.exit(1);
});

// auditPackage(
//   `https://github.com/webpack/webpack-dev-server/tree/v4.9.3`,
//   `D:\\Codes\\MCP\\learn-project\\mcp-vulnerability-checker\\work`
// ).then(() => {
//   console.log('远程工程审计完成');
// });
